---
title: Enhance import-export with OVA
category: feature
authors: arik
wiki_category: Feature
wiki_title: Features/Enhance import-export with OVA
wiki_revision_count: 1
wiki_last_updated: 2017-03-20
feature_name: Enhance import-export with OVA
feature_modules: engine, vdsm
feature_status: 
---

# Backgroud
Open Virtual Appliance (OVA) is a package that contains the different elements of a Virual Machine (VM). OVA is typically a tar archive file that includes the configuration of the VM in the form of the Open Virtualization Format (OVF) as well as virtual disks and other VM-related data.  

OVA is a known format that is used by different organizations and virtualization platforms. Its specification can be found [here](http://www.dmtf.org/standards/ovf). The standard aims at being an ["open, secure, portable, efficient and extensible format for the packaging and distribution of software to be run in virtual machines"](https://en.wikipedia.org/wiki/Open_Virtualization_Format).  

Recently, oVirt was enhanced with support for importing OVAs that were generated by VMware. In addition, oVirt makes an extensive use of the OVF standard to describe VM configuration in, e.g., VM snapshots and exported VMs.  

The ability to package all the VM data, optionally compressed, in one file eases the processes of backing up a VM and porting a VM to a different platform or hypervisor. Unfortunately, the portability is limited by compatibility issues. Different disk formats, drivers, guest-agents, and OVF structure, hinder the ability to import any OVA to any platform. Therefore, different organizations develop their own conversions tools, like Red Hat's [virt-v2v](http://libguestfs.org/virt-v2v.1.html), for converting VMs from other platforms to their platform.   

# Scope
This feature is about enhancing the import VM and export VM processes in oVirt by making a broader use of the OVA format.  

## Upload OVA
Today, the process of importing an OVA is limited to OVA files compatible with those produced by VMware and requires one to manually copy the OVA file into one of hosts managed by oVirt and set the file permissions to vdsm:kvm. It is a cumbersome and error-prone process.  

This feature provides a broader and more user-friendly alternative that enables one to upload a local OVA file straight from the browser (much like the upload-image functionality that was recently added to oVirt).  

It would be possible to upload OVA files that were generated either by oVirt or by external sources. OVA files that were generated by external sources will be converted using virt-v2v, thus the supported external sources are limited to these whose OVA files can be converted by virt-v2v.  

## Export as OVA
Today, users are provided with two ways to migrate VMs and templates between environments. First, one can use an export domain. However, this approach is suitable only for migration between different oVirt environments. Moreover, there is a plan to drop the support for export domains. Second, one can detach a data domain and attach it to another setup. This way is tailored to disaster recovery and less fits the migration flow due to the side effects in detaching a data domain.  

This feature provides an alternative way for a migration between environments by generating an OVA from an existing VM or template. By encapsulating all VM/template data (optionally compressed) in a single file, we achieve an improved portability. By being aligned with the common OVA specification (rather than our unique structure of a storage domain), we achieve 
better compatibility with other platforms.  

The OVA file would be created at a given path within a particular host (this capability is targeted for extracting the VM/template into an external storage used for backup/migration). In addition, it will include neither snapshots nor the template that the VM may be based on.  

## Enhance Import OVA
This feature enhances the current support provided for import OVA files in two ways. First, it would be possible to specify a path to OVA that was generated by oVirt. Import of OVA that was generated by oVirt does not involve conversion and thus, should be faster than importing OVA files generated by others.  

Second, in order to provide better support for typical backup/restore and migration processes we enable listing all the OVA files in a given directory.  

## Download OVA
This feature will leverage the implementation of the planned download-image to provide similar functionality for OVA files.  

# Design
This section details the high-level design of the different aspects described in the previous section.

## Upload OVA
In principle, uploading an OVA is similar to uploading an image. However, it is more challenging because OVA is a more complex resource than an image.  

The upload process would be implemented differently depending on whether the OVA was generated by oVirt or by other source (and thus requires conversion). In both cases, the user will be able to select a file from within a browser and be presented with the VM configuration that will allow him to configure the parameters for the import process:

1. The user selects an OVA file from within the browser.
2. The front-end sends the OVF to the back-end.
3. The back-end parses the OVF and returns back an object that represents the VM.
4. The front-end displays the VM configuration and allows the user to configure the parameters for the import (namely, VM name, destination storage, and networks).

From this point on, the process depends on the source of the OVA. Note that the source is returned to the front-end by the back-end in the _origin_ field of the VM.  

### Upload OVA generated by oVirt
If the OVA was generated by oVirt, the rest of the process will be:

1. The back-end adds the VM entity into the database.
2. The back-end creates the destination volumes for the VM disks using the existing process for this in oVirt.
3. The back-end requests the imageio proxy to prepare to upload-ova with a list of parameters per disk. Namely, these parameters contain the destination path of the disk, its size, and a flag that indicates whether it is compressed or not.
4. The proxy returns a URL (similar to the upload-image flow).
5. The back-end passes this URL to the front-end (similar to the upload-image flow).
6. The front-end starts transmitting the **disks** one by one.
7. The proxy receives the input stream, uncompress it on-the-fly if needed, and streams it to the relevant destination volume.

### Upload OVA generated by an external source
If the OVA was generated by external source, the rest of the process will be:  

1. The back-end adds the VM entity into the database.
2. The back-end creates a temporary volume to store the OVA in.
3. The back-end requests (through VDSM) the imagoio proxy to prepare to upload-image-like process.
4. The proxy returns a URL (similar to the upload-image flow).
5. The back-end passes this URL to the front-end (similar to the upload-image flow).
6. The front-end starts transmitting the **whole OVA**.
7. The proxy streams the input into the created volume.
8. When the streaming is done, the back-end triggers the existing convert OVA method.
9. The back-end asks to remove the temporary volume upon completion.

Note that this is a second-priority task.  

## Export as OVA
The user will be able to specify a VM or a template to be exported as an OVA. In that case, the user needs to provide a path on a host where the OVA file is going to be created. The export process will then be comprised of the following operations:  

1. The front-end passes the back-end a VM (or template) to export and a path on a host that the OVA should be created in.
2. Each of the disks of the VM/template that either contains more than one volume or whose volume is not raw will be collapsed and converted to raw at some storage domain (TBD: sparsed?).
3. A raw volume for the target OVA will be created in the specified path on the specified host. Its size would be the sum of the actual size of the VM disks + size for headers + size of OVF.
4. The back-end produces the configuration of the entity to export in the form of an OVF.
3. VDSM writes the OVF and the content of the disks according to the OVA specification to the OVA volume.
4. The back-end asks to remove the temporary disk volumes upon completion.

## Enhance Import OVA

### Import OVA generated by oVirt
Importing an OVA that was generated by oVirt won't involve virt-v2v and will be similar to the upload-ova process:  

1. VDSM extracts the OVF from the OVA.
2. The front-end allows the user to configure the parameters for the import.
3. The back-end adds the VM(/template) entity into the database.
4. The back-end asks VDSM to create volumes for the virtual disks.
5. VDSM requests imageio proxy to start upload-OVA with the relevant parameters.
6. VDSM starts sending the content of the disks from the OVA to the proxy which in turn streams it into the corresponding volumes.

### Listing several OVA files within a directory
It will be possible to trigger mass import of OVA files that reside within the same directory:

1. The front-end passes a path to a directory on a host.
2. VDSM iterates the OVA files in the given directory and extracts the OVF files within them.
3. The back-end parses the OVF configuration and returns to the UI a list of VMs.
4. The user can select a subset of the OVA files and proceed with setting the parameters of the import process.
5. From this point on, the process is similar to a typical import flow.

Note that we anyway need the ability to parse an OVF that resides within an OVA by the back-end. It could be useful to change the existing process of importing an OVA produced by VMware such that the OVF will be sent to the engine instead of being parsed by VDSM.  

## Download OVA
This part depends on the implementation of download-image. In theory, the process should be a combination of export-as-ova and download-image:

1. The front-end passes the back-end a VM (or template) to export and stores a local file to write the OVA to.
2. Each of the disks of the entity to export that either contains more than one volume or whose volume is not raw will be collapsed and converted to raw at some storage domain.
3. The back-end asks (through VDSM) imageio proxy to prepare to download-ova.
4. The returned URL to read from is sent to the front-end.
5. The returned URL to write to is passed to VDSM along with the data to write (the configuration of the entity to export in the form of an OVF and the volumes to export).
6. VDSM writes the OVF and the content of the disks according to the OVA specification to the given URL.
7. The front-end reads from the given URL and streams the data into the destination file.
8. The back-end asks to remove the temporary disk volumes upon completion.

Steps 2,6,8 are similar to those in the export-as-ova process. Steps 1,3,4,5,7 are similar to those that would typically be needed for download-image.

Note that the feasibility of this task depends on the progress with download-image.
