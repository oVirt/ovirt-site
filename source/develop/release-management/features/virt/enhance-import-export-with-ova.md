---
title: Enhance import-export with OVA
category: feature
authors: arik
feature_name: Enhance import-export with OVA
feature_modules: engine, vdsm
feature_status: planning
---

# Background
Open Virtual Appliance (OVA) is a package that contains the different elements of a virtual machine (VM). OVA is typically a tar archive file that includes the configuration of the VM in the form of the Open Virtualization Format (OVF) as well as virtual disks and other VM-related data.  

OVA is a known format that is used by different organizations and virtualization platforms. Its specification can be found [here](http://www.dmtf.org/standards/ovf). The standard provides an ["open, secure, portable, efficient and extensible format for the packaging and distribution of software to be run in virtual machines"](https://en.wikipedia.org/wiki/Open_Virtualization_Format).  

Recently, oVirt was enhanced with support for importing OVAs that were generated by VMware. oVirt also makes extensive use of the OVF standard to describe VM configurations, such as VM snapshots and exported VMs.  

The ability to package all the VM data, optionally compressed, in one file eases the processes of backing up a VM and porting a VM to a different platform or hypervisor. Unfortunately, the portability is limited by compatibility issues. Different disk formats, drivers, guest-agents, and OVF structure, hinder the ability to import any OVA to any platform. Therefore, different organizations develop their own conversions tools, like Red Hat's [virt-v2v](http://libguestfs.org/virt-v2v.1.html), for converting VMs from other platforms to their platform.   

# Scope
This feature enhances import VM and export VM processes in oVirt, by making a broader use of the OVA format.  

## Uploading an OVA
Today, the process of importing an OVA is limited to OVA files compatible with those produced by VMware and requires to make the OVA file accessible, with the right file permissions (vdsm:kvm), to one of the hosts managed by oVirt. It is a cumbersome and error-prone process.  

This feature provides a broader and more user-friendly alternative that enables one to upload a local OVA file directly from a client (the client can be a browser or based on rest-api, like the clients supported for the upload-image functionality that was recently added to oVirt).  

This feature allows the uploading of OVA files that were generated either by oVirt or by external sources. Officially, the only external source being supported is VMware. In practice, the process could work with OVA files generated by other source, as long as their OVF configuration contains the data oVirt consumes (in the expected form), and virt-v2v knows how to convert them.

## Exporting a VM or Template as an OVA
Currently, users are provided with two ways to migrate VMs and templates between environments. One option is to use an export domain. However, this approach is suitable only for migration between separated oVirt environments. Moreover, there is a plan to drop the support for export domains. A second option is to detach a data domain and attach it to another setup. This option was desiged with disaster recovery in mind. However, because of the side effects associated with detaching a data domain, it is less suited to this migration flow.  

This feature provides an alternative way for a migration between environments by generating an OVA from an existing VM or template. By encapsulating all VM/template data in a single file, we achieve an improved portability. By being aligned with the common OVA specification (rather than our unique structure of a storage domain), we achieve better compatibility with other platforms.  

The OVA file would be streamed into imageio proxy, enabling its creation on a variety of locations (path on host in the data-center, NFS share, etc). In addition, it will include neither snapshots nor the template that the VM may be based on.  

Moreover, this feature enables a running VM to be exported without the need for any downtime. Today, VM shutdown is required.  

## An Enhancement for Importing OVAs
This feature enhances the existing support for importing OVA files that are accessible to the host, by enabling to specify a path to an OVA file that was generated by oVirt. Importing an OVAfile that was generated by oVirt does not involve the adaptation needed for OVA files generated by other platforms (e.g., installing kvm-specific drivers) and thus, should be faster than importing of such OVA files.  

## Downloading an OVA
This feature will leverage the implementation of the planned download-image to provide similar functionality for OVA files (i.e., download a VM/template as OVA on the client's machine).  

# Design
The following section describes the high-level design for the different aspects described in the previous section.

## Uploading an OVA
In principle, uploading an OVA is similar to uploading an image. However, it is more challenging because OVA is a more complex resource than an image.  

The upload process would be implemented differently depending on whether the OVA was generated by oVirt (or more accurately, that the disks within the OVA are of type raw or qcow) or by other source (and thus requires adaptation). In both cases, the user will be able to select a file and then be provided with the VM configuration that allows him to configure the parameters for the import process.  

### Uploading an OVA Generated by oVirt
The following figure depicts the import process of an OVA that was generated by oVirt:

![](../../../../images/wiki/upload-ova.png)

1. The front end retrieves the OVF configuration from the OVA.
2. The front end sends the OVF configuration to the back end.
3. The back end parses the OVF configuration and returns a VM to the front end.
4. The front end sends (optionally customized) parameters of the import process to the back end.
5. The back end persists the VM into the database.
6. The back end triggers the creation of the target VM disks on the storage domain.
7. The back end sends the import parameters - including the destination disks - to imageio-proxy, which sends them to imageio.
8. Imageio-proxy sends the engine a URL to write to. This URL is sent to the front end.
9. The front end streams the **whole OVA** to imageio-proxy, which streams it to imageio.
10. Imageio reads the data and according to the import parameters streams the data into the corresponding target disks.

Notes:

1. The described process assumes that the disks are not compressed within the OVA. In order to support this, the back end would need to pass an indication to imageio-proxy as to whether or not each disk is compressed (step 7), so the proxy can decompress the data on-the-fly while streaming it to the destination volume (step 10).
2. In the figure above, the format of the disks within the OVA is QCOW. This will serve as the default format in all OVA files generated by oVirt. However, we should also support import of OVA files containing RAW format disks.
3. In the figure above, the destination volumes are in the RAW format. This is preferable format because these volumes will serve as base volumes, and the RAW format delivers better performance. However, the destination volumes may initially be in the COW format (copied as-is from the OVA file) and only later on converted to the RAW format.  

### Uploading an OVA Generated by an External Source
The following figure depicts the import process of an OVA file that was generated by an external source:

![](../../../../images/wiki/upload-external-ova.png)  

The process is similar to that of importing an OVA file generated by oVirt, except for the following steps:  
6. Only one temporary disk is created on the storage domain.  
10. The whole OVA file is streamed into the disk that has just been created.  
11. Convert the temporary disk to a VM using virt-v2v.  
12. Remove the temporary disk.  

Note:  

1. This process is not efficient in time and space, due to the creation of the temporary disk. Thus, we will suggest to make the OVA accessible to the host instead, especially in the case of mass import of OVA files. However, this process can be handy for importing one OVA file with loose time and space constraints.  
2. Therefore, it is a second-priority task.

## Exporting a VM or Template as an OVA
The user will be able to select a VM (or a template) to be exported as an OVA file. In such cases, the user needs to specify a path on a host where the OVA file will be created.  

The following figure depicts the process of exporting a VM with a single disk as an OVA file:  

![](../../../../images/wiki/export-ova.png)  

1. The front end sends the back end a VM and a path on a host.
2. The back end asks imagio-proxy to initialize a file at the given path with an estimated size of the produced OVA file.
3. Imageio creates the OVA file.
4. The disk is streamed from the back end to imageio-proxy, and then to imageio.
5. Imageio reads the disk and streams it into a QCOW volume within the OVA.
6. The complete OVF specification is sent from the back end to imageio-proxy. imageio-proxy sends the specification to imageio, and imageio streams it into the OVA file.  

Notes:

1. Step 5 is equivalent to `qemu-img convert` with the collapse option set and the target format set to QCOW.  
2. The OVF configuration needs to be streamed to the beginning of the OVA file (according to the OVA specification, the OVF should be the first tar entry inside the OVA file).  
3. The back end should be provided with the overall amount of data written to the disk entry in step 4, because this information needs to be set inside the OVF configuration.  
4. The OVA file will be created with a special extension (step 3) and would be renamed (that extension would be dropped) at the end of the process (step 6). That is done in order to enable tools that synchronize shares between various deployments to differentiate partial and complete files.  

## An Enhancement for Import OVAs
Importing an OVA that was generated by oVirt won't involve virt-v2v and will be similar to the upload-ova process:  

![](../../../../images/wiki/import-ova.png)  

1. The front end sends the back end a VM and a path on a host.  
2. The back end retrieves the OVF configuration from the OVA using an agent located on the host (Imageio/Other).  
3. The back end parses the OVF configuration and returns a VM to the front end.
4. The front end sends (optionally customized) parameters of the import process to the back end.
5. The back end persists the VM into the database.
6. The back end triggers the creation of the target VM disks on the storage domain.
7. The back end sends the import parameters, including the destination disks, to imageio-proxy, that sends them to imageio.  
8. Imageio reads the disk from the OVA and according to the import parameters streams the data into the corresponding target disks.

## Downloading an OVA
This part depends on the implementation of the download-image flow. In theory, it should look like this:  

![](../../../../images/wiki/download-ova.png)  

1. The front end passes the back end a VM (or template) to download.
2. The back end sends import parameters to imageio-proxy in order to prepare to download-ova.
3. The URL that is returned by imageio-proxy is returned to the front end through the back end.
4. The front end initialize a target file to write the OVA to and starts listening on the URL.
5. The back end passes imageio-proxy the disk to copy and imageio-proxy delivers it to imageio.
6. Imageio starts reading the disk, converting it to QCOW and sends it to the URL. The front end then streams the data into the target file.
7. The back end sends imageio-proxy the OVF configuration, which sends it to imageio that writes it to the URL. The front end then streams the data into the target file.
