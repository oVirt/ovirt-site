---
title: Enhance import-export with OVA
category: feature
authors: arik
feature_name: Enhance import-export with OVA
feature_modules: engine, vdsm
feature_status: planning
---

# Background
Open Virtual Appliance (OVA) is a package that contains the different elements of a virtual machine (VM). OVA is typically a tar archive file that includes the configuration of the VM in the form of the Open Virtualization Format (OVF) as well as virtual disks and other VM-related data.  

OVA is a known format that is used by different organizations and virtualization platforms. Its specification can be found [here](http://www.dmtf.org/standards/ovf). The standard provides an ["open, secure, portable, efficient and extensible format for the packaging and distribution of software to be run in virtual machines"](https://en.wikipedia.org/wiki/Open_Virtualization_Format).  

Recently, oVirt was enhanced with support for importing OVAs that were generated by VMware. oVirt also makes extensive use of the OVF standard to describe VM configurations, such as VM snapshots and exported VMs.  

The ability to package all the VM data, optionally compressed, in one file eases the processes of backing up a VM and porting a VM to a different platform or hypervisor. Unfortunately, the portability is limited by compatibility issues. Different disk formats, drivers, guest-agents, and OVF structure, hinder the ability to import any OVA to any platform. Therefore, different organizations develop their own conversions tools, like Red Hat's [virt-v2v](http://libguestfs.org/virt-v2v.1.html), for converting VMs from other platforms to their platform.   

# Scope
This feature enhances import VM and export VM processes in oVirt, by making a broader use of the OVA format.  

## Uploading an OVA
Today, the process of importing an OVA is limited to OVA files compatible with those produced by VMware and requires to make the OVA file accessible, with the right file permissions (vdsm:kvm), to one of the hosts managed by oVirt. It is a cumbersome and error-prone process.  

This feature provides a broader and more user-friendly alternative that enables one to upload a local OVA file directly from a client (the client can be a browser or based on rest-api, like the clients supported for the upload-image functionality that was recently added to oVirt).  

This feature allows the uploading of OVA files that were generated either by oVirt or by external sources. Officially, the only external source being supported is VMware. In practice, the process could work with OVA files generated by other source, as long as their OVF configuration contains the data oVirt consumes (in the expected form), and virt-v2v knows how to convert them.

## Exporting a VM or Template as an OVA
Currently, users are provided with two ways to migrate VMs and templates between environments. One option is to use an export domain. However, this approach is suitable only for migration between separated oVirt environments. Moreover, there is a plan to drop the support for export domains. A second option is to detach a data domain and attach it to another setup. This option was desiged with disaster recovery in mind. However, because of the side effects associated with detaching a data domain, it is less suited to this migration flow.  

This feature provides an alternative way for a migration between environments by generating an OVA from an existing VM or template. By encapsulating all VM/template data in a single file, we achieve an improved portability. By being aligned with the common OVA specification (rather than our unique structure of a storage domain), we achieve better compatibility with other platforms.  

The OVA file would be streamed into imageio proxy, enabling its creation on a variety of locations (path on host in the data-center, NFS share, etc). In addition, it will include neither snapshots nor the template that the VM may be based on.  

Moreover, this feature enables a running VM to be exported without the need for any downtime. Today, VM shutdown is required.  

## An Enhancement for Import OVAs
This feature enhances the existing support for importing OVA files that are accessible to the host, by enabling to specify a path to an OVA file that was generated by oVirt. Importing an OVAfile that was generated by oVirt does not involve the adaptation needed for OVA files generated by other platforms (e.g., installing kvm-specific drivers) and thus, should be faster than importing of such OVA files.  

## Downloading an OVA
This feature will leverage the implementation of the planned download-image to provide similar functionality for OVA files (i.e., download a VM/template as OVA on the client's machine).  

# Design
The following section describes the high-level design for the different aspects described in the previous section.

## Uploading an OVA
In principle, uploading an OVA is similar to uploading an image. However, it is more challenging because OVA is a more complex resource than an image.  

The upload process would be implemented differently depending on whether the OVA was generated by oVirt (or more accurately, that the disks within the OVA are of type raw or qcow) or by other source (and thus requires adaptation). In both cases, the user will be able to select a file and then be provided with the VM configuration that allows him to configure the parameters for the import process.  

### Uploading an OVA Generated by oVirt
The following figure depicts the import process of an OVA that was generated by oVirt:

![](../../../../images/wiki/upload-ova.png)

1. The front-end retrieves the OVF configuration from the OVA.
2. The front-end sends the OVF configuration to the back-end.
3. The back-end parses the OVF configuration and returns a VM to the front-end.
4. The front-end sends (an optionally customized) parameters of the import process to the back-end.
5. The back-end persists the VM.
6. The back-end triggers the creation of the target VM disks on the storage domain.
7. The back-end sends the import parameters, including the destination disks, to imageio-proxy, that sends them to imageio.
8. Imageio-proxy sends the engine a URL to write to. This URL is sent to the front-end.
9. The front-end streams the **whole OVA** to imageio-proxy, that streams it to imageio.
10. Imageio reads the data and according to the import parameters streams the data into the corresponding target disks.

Notes:

1. The described process assumes that the disks are not compressed within the OVA. In order to support this, the back-end would need to pass an indication to imageio-proxy of whether or not each disk is compressed (step 7) so the proxy could uncompress the data on-the-fly while streaming it to the destination volume (step 10).
2. In the figure above the format of the disks within the OVA is QCOW that is going to be the default format in OVA files generated by oVirt. However, we should support import of OVA that contains RAW disks as well.
3. In the figure above the destination volumes are of type RAW. While this is preferable because these volumes would serve as base volumes and the performance is better by having them of type RAW, the conversion of volumes on-the-fly from QCOW to RAW may be postponed and so at the beginning the target volumes would be of type QCOW.

### Uploading an OVA Generated by an External Source
The following figure depicts the import process of an OVA that was generated by external source:

![](../../../../images/wiki/upload-external-ova.png)  

The process differ from import of OVA generated by oVirt in the following steps:  
6. Only one temporary disk is created on the storage domain.  
10. The whole OVA is streamed into the created disk.  
11. Additional step that converts the streamed OVA and removed the temporary disk.  

Note:  

1. This process if not efficient in time and space, due to the creation of the temporary disk. Thus, we will suggest to make the OVA accessible to the host instead, especially in the case of mass import of OVA files. However, this process can be handy for a one upload with loose time- and space- constraints.  
2. Therefore, it is a second-priority task.

## Exporting a VM or Template as an OVA
The user will be able to specify a VM (or a template) to be exported as an OVA. In that case, the user needs to provide a path on a host where the OVA file should be created.  

The following figure depicts the process of exporting a VM with a single disk as OVA:  

![](../../../../images/wiki/export-ova.png)  

1. The front-end sends the back-end a VM and a path on a host.
2. The back-end asks imagio-proxy to initialize a file at the given path with an estimated size of the produced OVA.
3. Imageio creates the OVA file.
4. The back-end sends imageio-proxy the disk to stream, which sends it to imageio.
5. Imageio reads the disk and streams it into a QCOW volume within the OVA.
6. The back-end sends the complete OVF specification to imageio-proxy, which sends it to imageio that streams it into the OVA.

Notes:

1. Step 5 is equivalent to do qemu-img convert with the collapse option and the target format being QCOW, on-the-fly.
2. The streaming in step 5 should be done in a certain offset so the streaming of the OVA would be done into the beginning of the file (the OVF should be the first tar entry inside the OVA according to the OVA specification).
3. The back-end should receive the overall amount of data written to the disk entry in step 4 so it could be placed inside the OVF.  
4. The OVA file will be created with a special extension (step 3) and would be renamed (that extension would be dropped) at the end of the process (step 6). That is done in order to enable tools that synchronize shares between various deployments differentiate partial files and complete files.  

## An Enhancement for Import OVAs
Importing an OVA that was generated by oVirt won't involve virt-v2v and will be similar to the upload-ova process:  

![](../../../../images/wiki/import-ova.png)  

1. The front-end sends the back-end a VM and a path on a host.  
2. The back-end retrieved via an agent (VDSM/Imageio/Other) the OVF configuration from within the OVA.  
3. The back-end parses the OVF configuration and returns a VM to the front-end.
4. The front-end sends (an optionally customized) parameters of the import process to the back-end.
5. The back-end persists the VM.
6. The back-end triggers the creation of the target VM disks on the storage domain.
7. The back-end sends the import parameters, including the destination disks, to imageio-proxy, that sends them to imageio.  
8. Imageio reads the disk from the OVA and according to the import parameters streams the data into the corresponding target disks.

## Downloading an OVA
This part depends on the implementation of the download-image flow. In theory, it should look like that:  

![](../../../../images/wiki/download-ova.png)  

1. The front-end passes the back-end a VM (or template) to download.
2. The back-end sends import parameters to imageio-proxy in order to prepare to download-ova.
3. The URL that is returned by imageio-proxy is returned to the front-end through the back-end.
4. The front-end initialize a target file to write the OVA to and starts listening on the URL.
5. The back-end passes imageio-proxy the disk to copy and imageio-proxy delivers it to imageio.
6. Imageio starts reading the disk, converting it to QCOW and sends it to the URL. The front-end then streams the data into the target file.
7. The back-end sends imageio-proxy the OVF configuration, which sends it to imageio that writes it to the URL. The front-end then streams the data into the target file.
